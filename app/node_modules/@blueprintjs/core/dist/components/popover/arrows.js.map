{"version":3,"sources":["../src/components/popover/arrows.ts"],"names":[],"mappings":"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","file":"components/popover/arrows.js","sourcesContent":["import { CSSProperties } from \"react\";\n\nimport { Position } from \"../../common/position\";\n\n// this value causes popover and target edges to line up on 50px targets\nexport const MIN_ARROW_SPACING = 18;\n\nexport interface IDimensions {\n    height: number;\n    width: number;\n}\n\nexport interface IArrowPositionStyles {\n    arrow?: CSSProperties;\n    container?: CSSProperties;\n}\n\nexport function computeArrowOffset(sideLength: number, arrowSize: number, minimum = MIN_ARROW_SPACING) {\n    return Math.max(Math.round((sideLength - arrowSize) / 2), minimum);\n}\n\nexport function getPopoverTransformOrigin(position: Position,\n                                          arrowSize: number,\n                                          targetDimensions: IDimensions): string {\n    const offsetX = computeArrowOffset(targetDimensions.width, arrowSize);\n    const offsetY = computeArrowOffset(targetDimensions.height, arrowSize);\n    switch (position) {\n        case Position.TOP_LEFT:\n            return `${offsetX}px bottom`;\n        case Position.TOP_RIGHT:\n            return `calc(100% - ${offsetX}px) bottom`;\n        case Position.BOTTOM_LEFT:\n            return `${offsetX}px top`;\n        case Position.BOTTOM_RIGHT:\n            return `calc(100% - ${offsetX}px) top`;\n        case Position.LEFT_TOP:\n            return `right ${offsetY}px`;\n        case Position.LEFT_BOTTOM:\n            return `right calc(100% - ${offsetY}px)`;\n        case Position.RIGHT_TOP:\n            return `left ${offsetY}px`;\n        case Position.RIGHT_BOTTOM:\n            return `left calc(100% - ${offsetY}px)`;\n        default:\n            return undefined;\n    }\n}\n\nexport function getArrowPositionStyles(position: Position,\n                                       arrowSize: number,\n                                       ignoreTargetDimensions: boolean,\n                                       targetDimensions: IDimensions,\n                                       inline: boolean): IArrowPositionStyles {\n    // compute the offset to center an arrow with given hypotenuse in a side of the given length\n    const popoverOffset = (sideLength: number) => {\n        const offset = computeArrowOffset(sideLength, arrowSize, 0);\n        return offset < MIN_ARROW_SPACING ? MIN_ARROW_SPACING - offset : 0;\n    };\n    const popoverOffsetX = popoverOffset(targetDimensions.width);\n    const popoverOffsetY = popoverOffset(targetDimensions.height);\n    // TOP, RIGHT, BOTTOM, LEFT are handled purely in CSS because of centering transforms\n    switch (position) {\n        case Position.TOP_LEFT:\n        case Position.BOTTOM_LEFT:\n            return {\n                arrow: ignoreTargetDimensions ? {} : { left: computeArrowOffset(targetDimensions.width, arrowSize) },\n                container: { marginLeft: -popoverOffsetX },\n            };\n        case Position.TOP_RIGHT:\n        case Position.BOTTOM_RIGHT:\n            return {\n                arrow: ignoreTargetDimensions ? {} : { right: computeArrowOffset(targetDimensions.width, arrowSize) },\n                container: { marginLeft: popoverOffsetX },\n            };\n        case Position.RIGHT_TOP:\n        case Position.LEFT_TOP:\n            return {\n                arrow: ignoreTargetDimensions ? {} : { top: computeArrowOffset(targetDimensions.height, arrowSize) },\n                container: inline ? { top: -popoverOffsetY } : { marginTop: -popoverOffsetY },\n            };\n        case Position.RIGHT_BOTTOM:\n        case Position.LEFT_BOTTOM:\n            return {\n                arrow: ignoreTargetDimensions ? {} : { bottom: computeArrowOffset(targetDimensions.height, arrowSize) },\n                container: inline ? { bottom: -popoverOffsetY} : { marginTop: popoverOffsetY },\n            };\n        default:\n            return {};\n    }\n}\n"]}